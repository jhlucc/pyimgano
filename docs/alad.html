<!DOCTYPE html>
<html lang="zh-CN" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ALAD ç®—æ³•äº¤äº’å¼è¯¦è§£</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- 
        Chosen Palette: Scholarly Indigo 
        Application Structure Plan: A multi-section SPA design with interactive components. Sections include: 1. Overview, 2. Interactive 'Players' cards, 3. Step-by-step animated 'Training Game' flowchart on canvas, 4. Real-time 'Detection Test' canvas simulation, 5. Formula reference. This structure transforms the linear report into an exploratory learning tool, prioritizing hands-on understanding over passive reading. 
        Visualization & Content Choices: Report Info -> Goal -> Viz/Method. Intro -> Inform -> Hero Section -> HTML/CSS. Components -> Organize/Inform -> Interactive Cards -> JS click events. Training Process -> Explain Change/Process -> Animated Canvas Flowchart -> JS/Canvas API. Detection Logic -> Demonstrate Relationship -> Interactive Canvas Simulation -> JS/Canvas API. Formulas -> Inform -> Static Text -> HTML. This approach uses interactivity to make abstract concepts tangible. 
        CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. 
    -->
    <style>
        body { font-family: 'Noto Sans SC', sans-serif; }
        .chart-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
            height: 450px;
            max-height: 60vh;
        }
    </style>
</head>
<body class="bg-slate-50 text-slate-700">

    <!-- Header & Navigation -->
    <header class="bg-white/80 backdrop-blur-lg sticky top-0 z-50 shadow-sm">
        <div class="container mx-auto px-4">
            <nav class="flex justify-between items-center py-4">
                <h1 class="text-xl font-bold text-indigo-600">ALAD ç®—æ³•è¯¦è§£</h1>
                <div class="hidden md:flex space-x-6 text-sm font-medium">
                    <a href="#overview" class="hover:text-indigo-600 transition-colors">æ ¸å¿ƒæ€æƒ³</a>
                    <a href="#players" class="hover:text-indigo-600 transition-colors">æ ¸å¿ƒç»„ä»¶</a>
                    <a href="#training" class="hover:text-indigo-600 transition-colors">è®­ç»ƒåšå¼ˆ</a>
                    <a href="#detection" class="hover:text-indigo-600 transition-colors">æ£€æµ‹æ¨¡æ‹Ÿ</a>
                    <a href="#formulas" class="hover:text-indigo-600 transition-colors">æ ¸å¿ƒå…¬å¼</a>
                </div>
            </nav>
        </div>
    </header>

    <main class="container mx-auto px-4 py-8 md:py-16">

        <!-- Section 1: Overview -->
        <section id="overview" class="text-center mb-24">
            <h2 class="text-4xl md:text-5xl font-bold text-slate-800 mb-4">å¯¹æŠ—å­¦ä¹ ä¸å¼‚å¸¸æ£€æµ‹</h2>
            <p class="text-lg md:text-xl text-slate-600 max-w-3xl mx-auto">
                ALAD (Adversarially Learned Anomaly Detection) æ˜¯ä¸€ç§åŸºäºç”Ÿæˆå¯¹æŠ—ç½‘ç»œ (GAN) æ€æƒ³çš„å¼ºå¤§å¼‚å¸¸æ£€æµ‹ç®—æ³•ã€‚å®ƒä¸ç›´æ¥å­¦ä¹ â€œå¼‚å¸¸â€ï¼Œè€Œæ˜¯é€šè¿‡ä¸€åœºç²¾å¿ƒè®¾è®¡çš„â€œä¼ªé€ è€…â€ä¸â€œé‰´å®šå¸ˆâ€çš„å¯¹æŠ—æ¸¸æˆï¼Œæè‡´åœ°å­¦ä¹ â€œæ­£å¸¸æ•°æ®â€çš„å†…åœ¨è§„å¾‹ã€‚
            </p>
        </section>

        <!-- Section 2: The Players -->
        <section id="players" class="mb-24">
            <div class="text-center mb-12">
                <h3 class="text-3xl font-bold text-slate-800">æ¸¸æˆä¸­çš„ç©å®¶</h3>
                <p class="text-slate-600 mt-2">ç‚¹å‡»å¡ç‰‡äº†è§£æ¯ä¸ªç»„ä»¶çš„èŒè´£ã€‚</p>
            </div>
            <div class="grid md:grid-cols-2 lg:grid-cols-3 gap-8">
                <!-- Generator Team -->
                <div class="col-span-1 md:col-span-2 lg:col-span-3 bg-indigo-50 border-2 border-indigo-200 rounded-2xl p-6 text-center">
                    <h4 class="text-xl font-bold text-indigo-700 mb-2">ä¼ªé€ è€…å›¢é˜Ÿ (ç”Ÿæˆå™¨)</h4>
                    <p class="text-indigo-900">ç›®æ ‡ï¼šå­¦ä¹ å¹¶æ¨¡ä»¿çœŸå®æ•°æ®çš„ç”Ÿæˆè¿‡ç¨‹ï¼Œä¼å›¾ä»¥å‡ä¹±çœŸã€‚</p>
                </div>
                <div class="player-card bg-white p-6 rounded-2xl shadow-lg hover:shadow-xl hover:-translate-y-1 transition-all cursor-pointer">
                    <h5 class="text-lg font-bold mb-2">ğŸ¨ ç¼–ç å™¨ (Encoder)</h5>
                    <p class="text-sm text-slate-600">å°†é«˜ç»´çš„è¾“å…¥æ ·æœ¬ï¼ˆå¦‚å›¾ç‰‡ï¼‰å‹ç¼©ï¼Œå¹¶æ˜ å°„åˆ°ä¸€ä¸ªä½ç»´çš„æ½œåœ¨è¡¨ç¤ºï¼ˆç‰¹å¾ï¼‰ã€‚è¿™å°±åƒæ˜¯ä¸ºä¸€ä»¶å¤æ‚çš„æ–‡ç‰©ç»˜åˆ¶ä¸€å¹…é«˜åº¦æµ“ç¼©çš„â€œè®¾è®¡è‰å›¾â€ã€‚</p>
                </div>
                <div class="player-card bg-white p-6 rounded-2xl shadow-lg hover:shadow-xl hover:-translate-y-1 transition-all cursor-pointer">
                    <h5 class="text-lg font-bold mb-2">ğŸ¨ è§£ç å™¨ (Decoder)</h5>
                    <p class="text-sm text-slate-600">æ¥æ”¶ä¸€ä¸ªæ½œåœ¨å˜é‡ï¼ˆæ— è®ºæ˜¯çœŸå®çš„è¿˜æ˜¯ä¼ªé€ çš„ï¼‰ï¼Œå¹¶å°è¯•å°†å…¶è§£ç ã€é‡æ„ä¸ºä¸€ä¸ªä¸åŸå§‹æ•°æ®ç»´åº¦ç›¸åŒçš„é«˜ç»´æ ·æœ¬ã€‚è¿™å°±åƒæ˜¯æ ¹æ®â€œè®¾è®¡è‰-å›¾â€æ¥å¤åŸä¸€ä»¶æ–‡ç‰©ã€‚</p>
                </div>
                <div></div>

                <!-- Discriminator Team -->
                <div class="col-span-1 md:col-span-2 lg:col-span-3 bg-rose-50 border-2 border-rose-200 rounded-2xl p-6 text-center mt-8">
                    <h4 class="text-xl font-bold text-rose-700 mb-2">é‰´å®šå¸ˆå›¢é˜Ÿ (åˆ¤åˆ«å™¨)</h4>
                    <p class="text-rose-900">ä¸‰ä¸ªç‹¬ç«‹çš„ä¸“å®¶çº§é‰´å®šå¸ˆï¼Œå…±åŒæ„æˆå¼ºå¤§çš„é˜²å¾¡ä½“ç³»ã€‚</p>
                </div>
                <div class="player-card bg-white p-6 rounded-2xl shadow-lg hover:shadow-xl hover:-translate-y-1 transition-all cursor-pointer">
                    <h5 class="text-lg font-bold mb-2">ğŸ” D<sub>xx</sub> (æ•°æ®ä¸€è‡´æ€§é‰´å®šå¸ˆ)</h5>
                    <p class="text-sm text-slate-600">è´Ÿè´£åˆ¤æ–­ä¸¤ä»½â€œæ•°æ®â€æ˜¯å¦éƒ½æ¥è‡ªçœŸå®çš„åˆ†å¸ƒã€‚</p>
                </div>
                <div class="player-card bg-white p-6 rounded-2xl shadow-lg hover:shadow-xl hover:-translate-y-1 transition-all cursor-pointer">
                    <h5 class="text-lg font-bold mb-2">ğŸ” D<sub>zz</sub> (ç‰¹å¾ä¸€è‡´æ€§é‰´å®šå¸ˆ)</h5>
                    <p class="text-sm text-slate-600">è´Ÿè´£åˆ¤æ–­ä¸¤ä»½â€œç‰¹å¾â€ï¼ˆæ½œåœ¨å‘é‡ï¼‰æ˜¯å¦éƒ½æ¥è‡ªçœŸå®çš„åˆ†å¸ƒã€‚</p>
                </div>
                <div class="player-card bg-white p-6 rounded-2xl shadow-lg hover:shadow-xl hover:-translate-y-1 transition-all cursor-pointer">
                    <h5 class="text-lg font-bold mb-2">ğŸ” D<sub>xz</sub> (åŒ¹é…åº¦é‰´å®šå¸ˆ)</h5>
                    <p class="text-sm text-slate-600">è´Ÿè´£åˆ¤æ–­ä¸€ä»½â€œæ•°æ®â€å’Œä¸€ä»½â€œç‰¹å¾â€æ˜¯å¦æ˜¯åŸé…ã€‚</p>
                </div>
            </div>
        </section>

        <!-- Section 3: Training Game -->
        <section id="training" class="mb-24">
            <div class="text-center mb-12">
                <h3 class="text-3xl font-bold text-slate-800">è®­ç»ƒåšå¼ˆï¼šä¸€åœºç²¾å¿ƒè®¾è®¡çš„çŒ«é¼ æ¸¸æˆ</h3>
                <p class="text-slate-600 mt-2">é€šè¿‡ç‚¹å‡»æŒ‰é’®ï¼Œåˆ†æ­¥è§‚å¯Ÿè®­ç»ƒæµç¨‹ä¸­çš„æ•°æ®æµåŠ¨å’Œå¯¹æŠ—è¿‡ç¨‹ã€‚</p>
            </div>
            <div class="chart-container bg-white rounded-2xl shadow-lg p-4">
                <canvas id="trainingCanvas"></canvas>
            </div>
            <div class="flex justify-center space-x-4 mt-6">
                <button id="prevStepBtn" class="bg-slate-200 text-slate-700 font-semibold py-2 px-6 rounded-lg hover:bg-slate-300 transition-colors disabled:opacity-50">ä¸Šä¸€æ­¥</button>
                <button id="nextStepBtn" class="bg-indigo-600 text-white font-semibold py-2 px-6 rounded-lg hover:bg-indigo-700 transition-colors">ä¸‹ä¸€æ­¥</button>
            </div>
            <div id="training-explanation" class="mt-6 text-center bg-indigo-50 p-4 rounded-lg text-indigo-800 min-h-[60px]"></div>
        </section>

        <!-- Section 4: Detection Simulation -->
        <section id="detection" class="mb-24">
            <div class="text-center mb-12">
                <h3 class="text-3xl font-bold text-slate-800">æ£€æµ‹æ¨¡æ‹Ÿï¼šäº²æ‰‹å‘ç°å¼‚å¸¸</h3>
                <p class="text-slate-600 mt-2">æ‹–åŠ¨ä¸‹æ–¹çš„â€œæµ‹è¯•ç‚¹â€ï¼Œè§‚å¯Ÿå…¶é‡æ„è¯¯å·®å’Œå¼‚å¸¸åˆ†æ•°çš„å˜åŒ–ã€‚</p>
            </div>
            <div class="chart-container bg-white rounded-2xl shadow-lg p-4">
                <canvas id="detectionCanvas"></canvas>
            </div>
            <div class="text-center mt-6 bg-white p-4 rounded-lg shadow-md max-w-sm mx-auto">
                <p class="text-lg font-bold">æœ€ç»ˆå¼‚å¸¸åˆ†æ•°: <span id="anomalyScore" class="text-2xl text-rose-600 font-mono">0.00</span></p>
                <p id="detection-status" class="text-lg font-semibold text-green-600 mt-1">æ­£å¸¸</p>
            </div>
        </section>

        <!-- Section 5: Formulas -->
        <section id="formulas">
            <div class="text-center mb-12">
                <h3 class="text-3xl font-bold text-slate-800">æ ¸å¿ƒå…¬å¼</h3>
                <p class="text-slate-600 mt-2">ç®—æ³•èƒŒåçš„æ•°å­¦åŸç†ã€‚</p>
            </div>
            <div class="bg-white p-8 rounded-2xl shadow-lg max-w-4xl mx-auto space-y-8">
                <div>
                    <h4 class="font-bold text-lg mb-2">1. åˆ¤åˆ«å™¨æŸå¤±å‡½æ•°</h4>
                    <p class="text-sm bg-slate-100 p-4 rounded-md font-mono">L<sub>Dxx</sub> = E[log D<sub>xx</sub>(x,x)] + E[log (1 - D<sub>xx</sub>(x,xÌ‚))]</p>
                    <p class="text-xs text-slate-500 mt-2">D<sub>zz</sub> å’Œ D<sub>xz</sub> çš„æŸå¤±å‡½æ•°å½¢å¼ç±»ä¼¼ï¼Œç›®æ ‡éƒ½æ˜¯æœ€å¤§åŒ–å¯¹çœŸä¼ªæ ·æœ¬çš„åŒºåˆ†èƒ½åŠ›ã€‚</p>
                </div>
                <div>
                    <h4 class="font-bold text-lg mb-2">2. ç”Ÿæˆå™¨æ€»æŸå¤±</h4>
                    <p class="text-sm bg-slate-100 p-4 rounded-md font-mono">L<sub>Gen</sub><sup>total</sup> = L<sub>Gen</sub> + Î» Â· L<sub>Recon</sub></p>
                    <p class="text-xs text-slate-500 mt-2">ç”Ÿæˆå™¨çš„ç›®æ ‡æ˜¯æ¬ºéª—æ‰€æœ‰åˆ¤åˆ«å™¨ï¼ˆL<sub>Gen</sub>ï¼‰ï¼ŒåŒæ—¶å¯é€‰åœ°æœ€å°åŒ–é‡æ„è¯¯å·®ï¼ˆL<sub>Recon</sub>ï¼‰ã€‚</p>
                </div>
                <div>
                    <h4 class="font-bold text-lg mb-2">3. æœ€ç»ˆå¼‚å¸¸åˆ†æ•°</h4>
                    <p class="text-sm bg-slate-100 p-4 rounded-md font-mono">s(x) = ||D<sub>xx</sub>(x,x) - D<sub>xx</sub>(x,xÌ‚)||Â²</p>
                    <p class="text-xs text-slate-500 mt-2">å¼‚å¸¸åˆ†æ•°ç”±åˆ¤åˆ«å™¨ D<sub>xx</sub> å¯¹â€œçœŸå®-çœŸå®â€å¯¹å’Œâ€œçœŸå®-é‡æ„â€å¯¹çš„æ‰“åˆ†å·®å¼‚å†³å®šã€‚</p>
                </div>
            </div>
        </section>

    </main>

    <footer class="bg-slate-800 text-slate-300 mt-16">
        <div class="container mx-auto px-4 py-6 text-center text-sm">
            <p>ALAD ç®—æ³•äº¤äº’å¼è¯¦è§£ | çµæ„Ÿæºäº PyOD ç¤¾åŒº</p>
        </div>
    </footer>

    <script>
        // --- Section 2: Player Cards Interaction ---
        const playerCards = document.querySelectorAll('.player-card');
        playerCards.forEach(card => {
            card.addEventListener('click', () => {
                card.classList.toggle('bg-indigo-100');
                card.classList.toggle('scale-105');
            });
        });

        // --- Section 3: Training Game Animation ---
        const trainingCanvas = document.getElementById('trainingCanvas');
        const trainingCtx = trainingCanvas.getContext('2d');
        const prevStepBtn = document.getElementById('prevStepBtn');
        const nextStepBtn = document.getElementById('nextStepBtn');
        const trainingExplanation = document.getElementById('training-explanation');

        let currentStep = 0;
        const totalSteps = 6;
        let components = {};
        let animationFrameId;

        const explanations = [
            "å¼€å§‹ï¼šæˆ‘ä»¬æœ‰çœŸå®çš„æ ·æœ¬Xå’Œéšæœºå™ªå£°Zä½œä¸ºè¾“å…¥ã€‚",
            "ç”Ÿæˆå™¨å·¥ä½œï¼šçœŸå®æ•°æ®Xé€šè¿‡ç¼–ç å™¨ç”Ÿæˆä¼ªé€ ç‰¹å¾Z_genï¼›éšæœºå™ªå£°Zé€šè¿‡è§£ç å™¨ç”Ÿæˆä¼ªé€ æ•°æ®X_genã€‚",
            "é‰´å®šä¼š (D_xz)ï¼šé‰´å®šå¸ˆD_xzå­¦ä¹ åŒºåˆ†(çœŸå®æ•°æ®, ä¼ªé€ ç‰¹å¾)å’Œ(ä¼ªé€ æ•°æ®, çœŸå®ç‰¹å¾)çš„åŒ¹é…åº¦ã€‚",
            "é‰´å®šä¼š (D_xx & D_zz)ï¼šé‰´å®šå¸ˆD_xxå’ŒD_zzå­¦ä¹ åŒºåˆ†æ•°æ®å’Œç‰¹å¾çš„ä¸€è‡´æ€§ã€‚",
            "ç”Ÿæˆå™¨åå‡»ï¼šç”Ÿæˆå™¨(Enc+Dec)æ›´æ–°å‚æ•°ï¼Œç›®æ ‡æ˜¯ç”Ÿæˆè¶³ä»¥éª—è¿‡æ‰€æœ‰é‰´å®šå¸ˆçš„ä¼ªé€ å“ã€‚",
            "è¾¾åˆ°å¹³è¡¡ï¼šç»è¿‡å¤šè½®å¯¹æŠ—ï¼Œç³»ç»Ÿè¾¾åˆ°å¹³è¡¡ã€‚ç¼–ç å™¨å’Œè§£ç å™¨å·²å®Œå…¨æŒæ¡æ­£å¸¸æ•°æ®çš„åˆ†å¸ƒã€‚"
        ];

        function resizeTrainingCanvas() {
            const container = trainingCanvas.parentElement;
            trainingCanvas.width = container.clientWidth;
            trainingCanvas.height = container.clientHeight;
            
            const w = trainingCanvas.width;
            const h = trainingCanvas.height;
            
            components = {
                x_real: { x: w * 0.15, y: h * 0.1, text: 'X_real' },
                z_real: { x: w * 0.85, y: h * 0.1, text: 'Z_real' },
                enc: { x: w * 0.15, y: h * 0.35, text: 'Encoder' },
                dec: { x: w * 0.85, y: h * 0.35, text: 'Decoder' },
                z_gen: { x: w * 0.15, y: h * 0.6, text: 'Z_gen' },
                x_gen: { x: w * 0.85, y: h * 0.6, text: 'X_gen' },
                d_xz: { x: w * 0.5, y: h * 0.85, text: 'D_xz' },
                d_xx: { x: w * 0.2, y: h * 0.85, text: 'D_xx' },
                d_zz: { x: w * 0.8, y: h * 0.85, text: 'D_zz' },
            };
            drawTrainingStep();
        }

        function drawComponent(comp, color = 'rgb(79, 70, 229)') {
            trainingCtx.fillStyle = color;
            trainingCtx.strokeStyle = color;
            trainingCtx.lineWidth = 2;
            trainingCtx.beginPath();
            trainingCtx.roundRect(comp.x - 40, comp.y - 15, 80, 30, [8]);
            trainingCtx.stroke();
            trainingCtx.fillStyle = color;
            trainingCtx.font = '14px "Noto Sans SC"';
            trainingCtx.textAlign = 'center';
            trainingCtx.textBaseline = 'middle';
            trainingCtx.fillText(comp.text, comp.x, comp.y);
        }
        
        function drawArrow(from, to, color = 'gray', dashed = false) {
            trainingCtx.beginPath();
            trainingCtx.strokeStyle = color;
            trainingCtx.lineWidth = 1.5;
            if (dashed) {
                trainingCtx.setLineDash([5, 5]);
            } else {
                trainingCtx.setLineDash([]);
            }
            trainingCtx.moveTo(from.x, from.y + 15);
            trainingCtx.lineTo(to.x, to.y - 15);
            trainingCtx.stroke();
            // Arrowhead
            trainingCtx.save();
            trainingCtx.translate(to.x, to.y - 15);
            trainingCtx.rotate(Math.atan2(to.y - from.y, to.x - from.x) - Math.PI / 2);
            trainingCtx.beginPath();
            trainingCtx.moveTo(0, 0);
            trainingCtx.lineTo(-5, -10);
            trainingCtx.lineTo(5, -10);
            trainingCtx.closePath();
            trainingCtx.fillStyle = color;
            trainingCtx.fill();
            trainingCtx.restore();
        }

        function drawTrainingStep() {
            trainingCtx.clearRect(0, 0, trainingCanvas.width, trainingCanvas.height);
            Object.values(components).forEach(comp => drawComponent(comp));

            if (currentStep >= 1) { // Step 1: Generator
                drawArrow(components.x_real, components.enc, 'blue');
                drawArrow(components.enc, components.z_gen, 'blue');
                drawArrow(components.z_real, components.dec, 'blue');
                drawArrow(components.dec, components.x_gen, 'blue');
            }
            if (currentStep >= 2) { // Step 2: D_xz
                drawArrow(components.x_real, components.d_xz, 'red', true);
                drawArrow(components.z_gen, components.d_xz, 'red', true);
                drawArrow(components.x_gen, components.d_xz, 'red', true);
                drawArrow(components.z_real, components.d_xz, 'red', true);
            }
            if (currentStep >= 3) { // Step 3: D_xx, D_zz
                 drawArrow(components.x_real, components.d_xx, 'red', true);
                 drawArrow(components.x_gen, components.d_xx, 'red', true);
                 drawArrow(components.z_real, components.d_zz, 'red', true);
                 drawArrow(components.z_gen, components.d_zz, 'red', true);
            }
            if (currentStep >= 4) { // Step 4: Generator learns
                drawArrow(components.d_xz, components.enc, 'green', true);
                drawArrow(components.d_xz, components.dec, 'green', true);
            }
            if (currentStep >= 5) { // Step 5: Balance
                trainingCtx.font = 'bold 24px "Noto Sans SC"';
                trainingCtx.fillStyle = 'rgba(22, 163, 74, 0.8)';
                trainingCtx.fillText('è¾¾åˆ°å¹³è¡¡', trainingCanvas.width / 2, trainingCanvas.height / 2);
            }

            trainingExplanation.textContent = explanations[currentStep];
            prevStepBtn.disabled = currentStep === 0;
            nextStepBtn.disabled = currentStep === totalSteps - 1;
        }

        nextStepBtn.addEventListener('click', () => {
            if (currentStep < totalSteps - 1) {
                currentStep++;
                drawTrainingStep();
            }
        });
        prevStepBtn.addEventListener('click', () => {
            if (currentStep > 0) {
                currentStep--;
                drawTrainingStep();
            }
        });

        window.addEventListener('resize', resizeTrainingCanvas);
        resizeTrainingCanvas();

        // --- Section 4: Detection Simulation ---
        const detectionCanvas = document.getElementById('detectionCanvas');
        const detectionCtx = detectionCanvas.getContext('2d');
        const scoreSpan = document.getElementById('anomalyScore');
        const statusSpan = document.getElementById('detection-status');

        let isDragging = false;
        let testPoint = { x: 0, y: 0 };
        let clusterCenter = { x: 0, y: 0 };
        let normalPoints = [];
        const numNormalPoints = 50;

        function resizeDetectionCanvas() {
            const container = detectionCanvas.parentElement;
            detectionCanvas.width = container.clientWidth;
            detectionCanvas.height = container.clientHeight;
            
            clusterCenter = { x: detectionCanvas.width / 2, y: detectionCanvas.height / 2 };
            testPoint = { x: clusterCenter.x + 50, y: clusterCenter.y - 50 };
            
            normalPoints = [];
            for (let i = 0; i < numNormalPoints; i++) {
                const angle = Math.random() * 2 * Math.PI;
                const radius = Math.random() * Math.min(detectionCanvas.width, detectionCanvas.height) * 0.2;
                normalPoints.push({
                    x: clusterCenter.x + Math.cos(angle) * radius,
                    y: clusterCenter.y + Math.sin(angle) * radius
                });
            }
            drawDetection();
        }

        function drawDetection() {
            detectionCtx.clearRect(0, 0, detectionCanvas.width, detectionCanvas.height);
            
            // Draw normal cluster
            normalPoints.forEach(p => {
                detectionCtx.beginPath();
                detectionCtx.arc(p.x, p.y, 3, 0, 2 * Math.PI);
                detectionCtx.fillStyle = 'rgba(79, 70, 229, 0.5)';
                detectionCtx.fill();
            });

            // Calculate reconstruction and score
            const dist = Math.sqrt((testPoint.x - clusterCenter.x)**2 + (testPoint.y - clusterCenter.y)**2);
            const maxDist = Math.min(detectionCanvas.width, detectionCanvas.height) / 2;
            const anomalyScore = Math.min((dist / maxDist)**2 * 5, 10); // Scaled score
            
            // Reconstructed point is pulled towards the cluster center
            const pullFactor = 1 - Math.tanh(dist / maxDist);
            const reconPoint = {
                x: clusterCenter.x + (testPoint.x - clusterCenter.x) * pullFactor,
                y: clusterCenter.y + (testPoint.y - clusterCenter.y) * pullFactor
            };

            // Draw line for reconstruction error
            detectionCtx.beginPath();
            detectionCtx.strokeStyle = 'rgba(220, 38, 38, 0.7)';
            detectionCtx.lineWidth = 2;
            detectionCtx.setLineDash([6, 3]);
            detectionCtx.moveTo(testPoint.x, testPoint.y);
            detectionCtx.lineTo(reconPoint.x, reconPoint.y);
            detectionCtx.stroke();
            detectionCtx.setLineDash([]);

            // Draw points
            detectionCtx.beginPath();
            detectionCtx.arc(reconPoint.x, reconPoint.y, 6, 0, 2 * Math.PI);
            detectionCtx.fillStyle = 'rgba(160, 160, 160, 0.8)';
            detectionCtx.fill();
            detectionCtx.fillText('é‡æ„ç‚¹', reconPoint.x, reconPoint.y - 15);

            detectionCtx.beginPath();
            detectionCtx.arc(testPoint.x, testPoint.y, 8, 0, 2 * Math.PI);
            detectionCtx.fillStyle = isDragging ? 'rgb(220, 38, 38)' : 'rgb(244, 63, 94)';
            detectionCtx.fill();
            detectionCtx.fillStyle = 'black';
            detectionCtx.font = '12px "Noto Sans SC"';
            detectionCtx.textAlign = 'center';
            detectionCtx.fillText('æµ‹è¯•ç‚¹ (æ‹–åŠ¨æˆ‘)', testPoint.x, testPoint.y - 20);

            // Update UI
            scoreSpan.textContent = anomalyScore.toFixed(2);
            if (anomalyScore > 1.5) {
                statusSpan.textContent = 'å¼‚å¸¸';
                statusSpan.className = 'text-lg font-semibold text-rose-600 mt-1';
            } else {
                statusSpan.textContent = 'æ­£å¸¸';
                statusSpan.className = 'text-lg font-semibold text-green-600 mt-1';
            }
        }

        function getMousePos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: evt.clientX - rect.left,
                y: evt.clientY - rect.top
            };
        }

        detectionCanvas.addEventListener('mousedown', (e) => {
            const pos = getMousePos(detectionCanvas, e);
            const dist = Math.sqrt((pos.x - testPoint.x)**2 + (pos.y - testPoint.y)**2);
            if (dist < 15) {
                isDragging = true;
            }
        });

        detectionCanvas.addEventListener('mouseup', () => {
            isDragging = false;
            drawDetection();
        });
        
        detectionCanvas.addEventListener('mouseout', () => {
            isDragging = false;
            drawDetection();
        });

        detectionCanvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const pos = getMousePos(detectionCanvas, e);
                testPoint.x = pos.x;
                testPoint.y = pos.y;
                drawDetection();
            }
        });

        window.addEventListener('resize', resizeDetectionCanvas);
        resizeDetectionCanvas();

    </script>
</body>
</html>
